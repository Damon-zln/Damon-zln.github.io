<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java基础]]></title>
    <url>%2F2020%2F02%2F26%2FJava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JDK 和 JRE 有什么区别？ JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。 JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。 == 和 equals 的区别是什么？ == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。 equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 举例： 1234567891011121314151617public class test1 &#123; public static void main(String[] args) &#123; String a = new String("ab"); // a 为一个引用 String b = new String("ab"); // b为另一个引用,对象的内容一样 String aa = "ab"; // 放在常量池中 String bb = "ab"; // 从常量池中查找 if (aa == bb) // true System.out.println("aa==bb"); if (a == b) // false，非同一对象 System.out.println("a==b"); if (a.equals(b)) // true System.out.println("aEQb"); if (42 == 42.0) &#123; // true System.out.println("true"); &#125; &#125;&#125; 说明： String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 hashCode 和 equals hashCode介绍 hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 为什么要有 hashCode 我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 通过我们可以看出：hashCode() 的作用就是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()在散列表中才有用，在其它情况下没用。在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。 hashCode() 与 equals() 的相关规定 如果两个对象相等，则hashcode一定也是相同的 两个对象相等,对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，它们也不一定是相等的 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖 hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） final 关键字final关键字主要用在三个地方：变量、方法、类。 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。 String、StringBuffer 和 StringBuilder 的区别是什么？String 为什么是不可变的？ 可变性 简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。 StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的。 AbstractStringBuilder.java 12345678abstract class AbstractStringBuilder implements Appendable, CharSequence &#123; char[] value; int count; AbstractStringBuilder() &#123; &#125; AbstractStringBuilder(int capacity) &#123; value = new char[capacity]; &#125; 线程安全性 String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 性能 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 三者总结 操作少量的数据: 适用String 单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer 自动装箱与拆箱 什么是装箱？什么是拆箱？ 装箱：基本类型转变为包装器类型的过程。拆箱：包装器类型转变为基本类型的过程。 装箱和拆箱的执行过程 装箱是通过调用包装器类的 valueOf 方法实现的 拆箱是通过调用包装器类的 xxxValue 方法实现的，xxx代表对应的基本数据类型。 如int装箱的时候自动调用Integer的valueOf(int)方法；Integer拆箱的时候自动调用Integer的intValue方法。 常见问题 整型的包装类 valueOf 方法返回对象时，在常用的取值范围内，会返回缓存对象。 浮点型的包装类 valueOf 方法返回新的对象。 布尔型的包装类 valueOf 方法 Boolean类的静态常量 TRUE | FALSE。 包含算术运算会触发自动拆箱。 存在大量自动装箱的过程，如果装箱返回的包装对象不是从缓存中获取，会创建很多新的对象，比较消耗内存。 String 类的常用方法都有那些？ equals：字符串是否相同 equalsIgnoreCase：忽略大小写后字符串是否相同 compareTo：根据字符串中每个字符的Unicode编码进行比较 compareToIgnoreCase：根据字符串中每个字符的Unicode编码进行忽略大小写比较 indexOf：目标字符或字符串在源字符串中位置下标 lastIndexOf：目标字符或字符串在源字符串中最后一次出现的位置下标 valueOf：其他类型转字符串 charAt：获取指定下标位置的字符 codePointAt：指定下标的字符的Unicode编码 concat：追加字符串到当前字符串 isEmpty：字符串长度是否为0 contains：是否包含目标字符串 startsWith：是否以目标字符串开头 endsWith：是否以目标字符串结束 format：格式化字符串 getBytes：获取字符串的字节数组 getChars：获取字符串的指定长度字符数组 toCharArray：获取字符串的字符数组 join：以某字符串，连接某字符串数组 length：字符串字符数 matches：字符串是否匹配正则表达式 replace：字符串替换 replaceAll：带正则字符串替换 replaceFirst：替换第一个出现的目标字符串 split：以某正则表达式分割字符串 substring：截取字符串 toLowerCase：字符串转小写 toUpperCase：字符串转大写 trim：去字符串首尾空格 普通类和抽象类有哪些区别？ 抽象类不能被实例化 抽象类可以有抽象方法，抽象方法只需申明，无需实现 含有抽象方法的类必须申明为抽象类 抽象类的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类 抽象方法不能被声明为静态 抽象方法不能用 private 修饰 抽象方法不能用 final 修饰 接口和抽象类有什么区别？ 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。 备注：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。 关于抽象类JDK 1.8以前，抽象类的方法默认访问权限为protectedJDK 1.8时，抽象类的方法默认访问权限变为default关于接口JDK 1.8以前，接口中的方法必须是public的JDK 1.8时，接口中的方法可以是public的，也可以是default的JDK 1.9时，接口中的方法可以是private的 java 中 IO 流有哪些？ 按数据流向:输入流和输出流 输入流：数据流向程序 输出流：数据从程序流出 按处理单位:字节流和字符流 字节流：一次读入或读出是8位二进制 字符流：一次读入或读出是16位二进制 JDK 中后缀是 Stream 是字节流；后缀是 Reader，Writer 是字符流 按功能功能:节点流和处理流 节点流：直接与数据源相连，读入或写出 处理流：与节点流一块使用，在节点流的基础上，再套接一层 最根本的四大类：InputStream(字节输入流)，OutputStream（字节输出流），Reader（字符输入流），Writer（字符输出流） 四大类的扩展，按处理单位区分 InputStream：FileInputStream、PipedInputStream、ByteArrayInputStream、BufferedInputstream、SequenceInputStream、DataInputStream、ObjectInputStream OutputStream：FileOutputStream、PipedOutputStream、ByteArrayOutputStream、BufferedOutputStream、DataOutputStream、ObjectOutputStream、PrintStream Reader：FileReader、PipedReader、CharArrayReader、BufferedReader、InputStreamReader Writer：FileWriter、PipedWriter、CharArrayWriter、BufferedWriter、InputStreamWriter、PrintWriter 常用的流 对文件进行操作：FileInputStream（字节输入流）、FileOutputStream（字节输出流）、FileReader（字符输入流）、FileWriter（字符输出流） 对管道进行操作：PipedInputStream（字节输入流）、PipedOutStream（字节输出流）、PipedReader（字符输入流）、PipedWriter（字符输出流） 字节/字符数组：ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader、CharArrayWriter Buffered 缓冲流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter 字节转化成字符流：InputStreamReader、OutputStreamWriter 数据流：DataInputStream、DataOutputStream 打印流：PrintStream、PrintWriter 对象流：ObjectInputStream、ObjectOutputStream 序列化流：SequenceInputStream 常见问题 既然有了字节流，为什么还要有字符流？ 问题本质想问：不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？ 回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。 BIO、NIO、AIO 有什么区别？ BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。（JDK1.4以前） NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。（JDK1.4） AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的 IO 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理。（JDK1.7） BIO：线程发起 IO 请求，不管内核是否准备好 IO 操作，从发起请求起，线程一直阻塞，直到操作完成。 NIO：线程发起 IO 请求，立即返回；内核在做好 IO 操作的准备之后，通过调用注册的回调函数通知线程做 IO 操作，线程开始阻塞，直到操作完成。 AIO：线程发起 IO 请求，立即返回；内存做好 IO 操作的准备之后，做 IO 操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做 IO 操作完成或者失败。 深拷贝 vs 浅拷贝 浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。 深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。 序列化ProtoBuffer Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。 优点 Protobuf 更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。 “向后”兼容性好，人们不必破坏已部署的、依靠“老”数据格式的程序就可以对数据结构进行升级。这样您的程序就可以不必担心因为消息结构的改变而造成的大规模的代码重构或者迁移的问题。因为添加新的消息中的 field 并不会引起已经发布的程序的任何改变。 Protobuf 语义更清晰，无需类似 XML 解析器的东西（因为 Protobuf 编译器会将 .proto 文件编译生成对应的数据访问类以对 Protobuf 数据进行序列化、反序列化操作）。 Protobuf 的编程模式比较友好，简单易学，同时它拥有良好的文档和示例，对于喜欢简单事物的人们而言，Protobuf 比其他的技术更加有吸引力。 不足 由于文本并不适合用来描述数据结构，所以 Protobuf 也不适合用来对基于文本的标记文档（如 HTML）建模。另外，由于 XML 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储，除非你有 .proto 定义，否则你没法直接读出 Protobuf 的任何内容。 运算符优先级相同优先级中，按结合顺序计算。大多数运算是从左至右计算，只有三个优先级是从右至左结合的，它们是单目运算符、条件运算符、赋值运算符。 基本的优先级需要记住： 指针最优，单目运算优于双目运算。如正负号。 先乘除（模），后加减。 先算术运算，后移位运算，最后位运算。请特别注意：1 &lt;&lt; 3 + 2 &amp; 7等价于 (1 &lt;&lt; (3 + 2)) &amp; 7. 逻辑运算最后计算。 异常Java中有Error和Exception，它们都是继承自Throwable类。 区别： Exception： 可以是可被控制(checked) 或不可控制的(unchecked)。 表示一个由程序员导致的错误。 应该在应用程序级被处理。 Error： 总是不可控制的(unchecked)。 经常用来用于表示系统错误或低层资源的错误。 如何可能的话，应该在系统级被捕捉。 异常和错误的区别：异常能被程序本身处理，错误是无法处理。 异常分类： Checked exception: 这类异常都是Exception的子类。异常的向上抛出机制进行处理，假如子类可能产生A异常，那么在父类中也必须throws A异常。可能导致的问题：代码效率低，耦合度过高。 Unchecked exception: 这类异常都是RuntimeException的子类，虽然RuntimeException同样也是Exception的子类，但是它们是非凡的，它们不能通过client code来试图解决，所以称为Unchecked exception 。 异常处理总结： try 块： 用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。 catch 块： 用于处理try捕获到的异常。 finally 块： 无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return 语句时，finally语句块将在方法返回之前被执行。 注：当try语句和finally语句中都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值。如下： 123456789public static int f(int value) &#123; try &#123; return value * value; &#125; finally &#123; if (value == 2) &#123; return 0; &#125; &#125; &#125; 如果调用 f(2)，返回值将是0，因为finally语句的返回值覆盖了try语句块的返回值。 在以下4种特殊情况下，finally块不会被执行： 在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行 在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行 程序所在的线程死亡。 关闭CPU。]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试算法题 --- 畅融金服]]></title>
    <url>%2F2019%2F02%2F25%2F%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言第一次遇见面试就一道算法题的，真是天下无奇不有。。。 问题描述写一个方法，输入一个奇数，输出如下格式： 输入1： 12// 输出：1 输入3： 123// 输出4 3 1 1 3 4 输入5： 1234// 输出12 8 5 1 4 3 3 4 1 5 8 12 输入7： 12345// 输出32 20 12 7 1 12 8 5 3 4 4 3 5 8 12 1 7 12 20 32 要求：输出是一个平行四边形，且是中心对称的，并且上下要竖直不能错开（输出不可以用 \t 来格式化，要求计算空格）。 思路 既然是中心对称的，那我们先从中间分开，看左边一半或是右边一半，这里我们先看右边一半吧，好理解一些，如下： 123413 45 8 127 12 20 32 然后就是找规律： 竖着看第一列，发现行数等于第一列的数字加一，然后除以2 每行的后面的数字等于前面的数字加上该数字上面的数字，如32=20+12 如果输入的n=7，那么最后一行是7，12，20，32，那么这四个数字的可以用下面的方法算出来： 12// 输入n=7,最后一行的数字：(2^0)*(n-0) (2^1)*(n-1) (2^2)*(n-2) (2^3)*(n-3) 至此，右边这一半已经解决了，就是算法怎么写的问题；右边的算法写出来之后，你会发现，把算法反过来写，就是左边的输出。 然后将两个输出组合在一起输出就能得到下面的结果，不是平行四边形 123432 20 12 7 112 8 5 3 44 3 5 8 121 7 12 20 32 最后，就是上面要求提到的，需要计算空格了，最终结果如下： 1234567// 输入7--------------------------------// 输出32 20 12 7 1 12 8 5 3 4 4 3 5 8 12 1 7 12 20 32 代码注：由于题目指定了是奇数，所以我在代码里面没有写奇/偶数判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272/** * Created by dazhan on 2019/2/25 22:27. */public class SquareFormatter &#123; /** * 方法一：使用的是数学方法，次方运算 （面试的时候，现场想出来的方法） * @param n */ public void format1(int n) &#123; String ss = String.valueOf((int)(Math.pow(2, ((n+1)/2 -1))*(n-((n+1)/2)+1))); int space = ss.length() + 1; for (int i = 1; i &lt;= (n+1)/2; i++) &#123; // 输出平行四边形 String sp = ""; for (int m = 1; m &lt; i; m++) &#123; while (sp.length() &lt; space) &#123; sp = sp + " "; &#125; System.out.print(sp); &#125; // 左边一半 for (int j = (n+1)/2 -i; j &gt;= 0; j--) &#123; String value = String.valueOf((int)(Math.pow(2, j)*(n-(2*i) -j +2))); // 计算空格 while (value.length() &lt; space) &#123; value = value + " "; &#125; System.out.print(value); &#125; // 右边一半 for (int j = 0; j &lt; i; j++) &#123; String value = String.valueOf((int)(Math.pow(2, j)*(2*i -1 -j))); // 计算空格 while (value.length() &lt; space) &#123; value = value + " "; &#125; System.out.print(value); &#125; System.out.println(); &#125; &#125; //////////////////////////////////////////////////////////////////////////////////////////// /** * 方法二：使用的是二维数组 （原公司同事想出来的方法） * @param n */ public void format2(int n) &#123; int[][] matrix = getMatrix(n); formatMatrix(matrix); &#125; private void formatMatrix(int[][] matrix) &#123; int line = matrix.length; int column = matrix[0].length; int max = matrix[line - 1][column - 1]; int digitNum = String.valueOf(max).length(); String formatter = "%-" + digitNum + "d"; String stringForZero = formatZero(digitNum); for (int i = line - 1; i &gt;= 0; i--) &#123; // print the matrix line by line reversely printlineReversed(matrix[i], formatter, stringForZero); // print the matrix line by line int revLine = line - i - 1; printLine(matrix[revLine], formatter, stringForZero); System.out.println(); &#125; &#125; private void printLine(int[] matrix, String formatter, String stringForZero) &#123; int col = matrix.length; for (int j = 0; j &lt; col; j++) &#123; if (matrix[j] == 0) &#123; System.out.print(stringForZero); &#125; else &#123; System.out.print(String.format(formatter, matrix[j])); &#125; System.out.print(" "); &#125; &#125; private void printlineReversed(int[] matrix, String formatter, String zeroStr) &#123; int col = matrix.length; for (int j = col - 1; j &gt;= 0; j--) &#123; if (matrix[j] == 0) &#123; System.out.print(zeroStr); &#125; else &#123; System.out.print(String.format(formatter, matrix[j])); &#125; System.out.print(" "); &#125; &#125; private String formatZero(int digitNum) &#123; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; digitNum; i++) &#123; stringBuilder.append(" "); &#125; return stringBuilder.toString(); &#125; private int[][] getMatrix(int n) &#123; int line = n / 2 + 1; int column = line; int[][] matrix = new int[line][column]; for (int i = 0; i &lt; line; i++) &#123; matrix[i][0] = 2 * i + 1; for (int j = 1; j &lt;= i; j++) &#123; matrix[i][j] = matrix[i][j - 1] + matrix[i - 1][j - 1]; &#125; &#125; return matrix; &#125; ///////////////////////////////////////////////////////////////////////////////////////////////// /** * 方法三：使用的是一维数组 （原公司同事想出来的方法） * @param n */ public void format3(int n) &#123; if (n == 1) &#123; System.out.println("1"); return; &#125; int loopNum = (n + 1) / 2; int[] matrix = getMatrix2(loopNum); formatMatrix(matrix, loopNum); &#125; private int[] getMatrix2(int loopNum) &#123; int totalNum = loopNum * (loopNum + 1) / 2; int[] array = new int[totalNum]; array[0] = 1; int offset = 1; int prev = 0; for (int i = offset; i &lt; totalNum; i += ++offset) &#123; array[i] = array[prev] + 2; prev = i; &#125; int suffix = 0; for (int i = 2; i &lt; totalNum; i++) &#123; if (array[i] == 0) &#123; array[i] = array[i - 1] + array[suffix++]; &#125; &#125; return array; &#125; private String formatLeadingSpaces(int digitNum) &#123; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; digitNum; i++) &#123; stringBuilder.append(" "); &#125; // delimiter between number stringBuilder.append(" "); return stringBuilder.toString(); &#125; private void formatMatrix(int[] matrix, int loopNum) &#123; int length = matrix.length; int max = matrix[length - 1]; int digitNum = String.valueOf(max).length(); String formatter = "%-" + digitNum + "d "; String leadingSpaces = formatLeadingSpaces(digitNum); int first = 0; int last = length - 1; for (int i = loopNum; i &gt; 0; i--) &#123; int prefix = loopNum - i; // print leading spaces // (n) pieces of leading spaces in line (n) // n = 0 ~ (loopNum - 1) for (int p = 0; p &lt; prefix; p++) &#123; System.out.print(leadingSpaces); &#125; // print the left side for (int j = 0; j &lt; i; j++) &#123; System.out.print(String.format(formatter, matrix[last--])); &#125; // print the right side for (int k = 0; k &lt;= prefix; k++) &#123; System.out.print(String.format(formatter, matrix[first++])); &#125; System.out.print("\n"); &#125; &#125;&#125;===============================================================================================/** * Created by dazhan on 2019/2/25 22:27. */public class SquareFormatterTest &#123; /** * 方法一：数学方法（次方） */ @Test public void testFormat1() &#123; SquareFormatter formatter = new SquareFormatter(); for (int i = 0; i &lt; 1000; i++) &#123; formatter.format1(19); &#125; &#125; /** * 方法二：二维数组 */ @Test public void testFormat2() &#123; SquareFormatter formatter = new SquareFormatter(); for (int i = 0; i &lt; 1000; i++) &#123; formatter.format2(19); &#125; &#125; /** * 方法三：一维数组 */ @Test public void testFormat3() &#123; SquareFormatter formatter = new SquareFormatter(); for (int i = 0; i &lt; 1000; i++) &#123; formatter.format3(19); &#125; &#125;&#125;===============================================================================================上面三个方法都同时运行1000遍，使用的时间如下：testFormat1 440ms 数学方法（次方）testFormat2 1s 108ms 二维数组testFormat3 535ms 一维数组按照上面的结果来看，数学方法时间最短，二维数组时间最长。-----------------------------------------------------------------------------------------------最终结果如下：5120 2816 1536 832 448 240 128 68 36 19 1 2304 1280 704 384 208 112 60 32 17 3 4 1024 576 320 176 96 52 28 15 5 8 12 448 256 144 80 44 24 13 7 12 20 32 192 112 64 36 20 11 9 16 28 48 80 80 48 28 16 9 11 20 36 64 112 192 32 20 12 7 13 24 44 80 144 256 448 12 8 5 15 28 52 96 176 320 576 1024 4 3 17 32 60 112 208 384 704 1280 2304 1 19 36 68 128 240 448 832 1536 2816 5120 总结遇到算法题的时候，千万不要放弃，把思路一点一点写下来，这样问题就解决了一半，这道题，我觉得难点就是把正序输出和反序输出组合起来的时候，有点费脑子……..当然了，我这个解法（方法一）是最常规的方法，肯定有比这个简单的方法的。。。只是当时时间有限，只能这样做了！QAQ]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求连续子数组最大和问题]]></title>
    <url>%2F2019%2F02%2F19%2F%E6%B1%82%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述在一个数组中（数组中的元素可以是负数），找出一个连续的子数组，要求子数组中的元素相加，和最大；然后输出这个最大值和最大子数组。 举例： 数组A = {1，3，-5，7，6，-1，3}，数组A的和最大的连续子数组是{7，6，-1，3}，最大和是15. 思路 先将这个数组中所有的连续子数组都找出来 再将每个子数组中的元素求和 比较出最大和的子数组 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * Created by Damon-zln on 2019/2/19. */public class Test &#123; public static void main(String[] args) throws Exception&#123; int[] arr = &#123;1, 2, 3&#125;; System.out.println(findAllSubArray(arr)); &#125; private static StringBuilder findAllSubArray(int[] arr) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) &#123; List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int j = i; j &lt; arr.length; j++) &#123; list.add(arr[j]); sb.append(list).append("|"); &#125; &#125; return sb; &#125;&#125;--------------------------------------------------------------------------------执行结果：[1]|[1, 2]|[1, 2, 3]|[2]|[2, 3]|[3]|================================================================================到这里，我的想法是，既然我们已经将子数组找出来了，那么我们可以在找子数组的时候，将子数组的元素和也算出来，有了子数组的和之后，就可以再添加一个判断，筛选出和最大的子数组，完美！！！具体代码如下：================================================================================/** * Created by Damon-zln on 2019/2/19. */public class Test &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 3, -5, 7, 6, -1, 3&#125;; System.out.println(findMaxSubArray(arr)); &#125; /** * 连续子数组的最大和 * @param arr 输入的数组 * @return map ：key是最大和，value是最大和对应的子数组 */ private static Map&lt;Integer, StringBuilder&gt; findMaxSubArray(int[] arr) &#123; int sum = 0; // 先将数组第一位赋值给max int max = arr[0]; // 初始化一个map，key用来存放最大连续子数组的和，value用来存放最大连续子数组 Map&lt;Integer, StringBuilder&gt; map = new HashMap&lt;&gt;(); // 初始化StringBuilder，用来存放和最大的子数组 StringBuilder sb = new StringBuilder(); // 第一个循环用来确定子数组开始的位置 for (int i = 0; i &lt; arr.length; i++) &#123; sum = 0; // 初始化一个集合用来存放子数组的元素 List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int j = i; j &lt; arr.length; j++) &#123; // 子数组内元素求和 sum += arr[j]; // 存放子数组的元素 list.add(arr[j]); // 判断比较当前子数组元素和是不是最大 if (sum &gt; max) &#123; max = sum; // 删除之前存放的子数组 sb.delete(0, sb.length()); // 添加当前的子数组 sb.append(list); &#125; &#125; &#125; map.put(max, sb); return map; &#125;&#125;--------------------------------------------------------------------------------执行结果：&#123;15=[7, 6, -1, 3]&#125;================================================================================到这里，基本已经完成了。然后，我去看了一下别人的做法，发现别人用一个循环就解决了问题，脑子里立刻就浮现了四个字：卧！槽！牛！逼！代码如下：================================================================================/** * Created by Damon-zln on 2019/2/19. */public class Test &#123; public static void main(String[] args) throws Exception&#123; int[] arr = &#123;1, 3, -5, 7, 6, -1, 3&#125;; System.out.println(findMaxSubArray(arr)); &#125; private static Map&lt;Integer, StringBuilder&gt; findMaxSubArray(int[] arr) &#123; int sum = 0; int max = arr[0]; Map&lt;Integer, StringBuilder&gt; map = new HashMap&lt;&gt;(); StringBuilder sb = new StringBuilder(); List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; list.add(arr[i]); if (sum &gt; max) &#123; max = sum; sb.delete(0, sb.length()); sb.append(list); // 如果累加和出现小于0的情况, 则和最大的子序列肯定不可能包含前面的元素 // 这时将累加和置0，从下个元素重新开始累加 &#125; else if (sum &lt; 0) &#123; sum = 0; list = new LinkedList&lt;&gt;(); &#125; &#125; map.put(max, sb); return map; &#125;&#125;--------------------------------------------------------------------------------执行结果：&#123;15=[7, 6, -1, 3]&#125; 感悟做了这道题，我感觉算法这个东西，真的是很牛逼，好的算法，可以极大的提升效率。 当我准备完结这道题的时候，我脑子里又冒出了一个问题：如果存在最大值的子数组不止一个呢？目前我只是取到了第一个…………我的天，这道题还没完~~~~ 未完…………….待续…………………QAQ]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用设计模式]]></title>
    <url>%2F2019%2F02%2F17%2F%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 单例模式 总结：一个类在JVM虚拟机中只有一个对象（永远是同一个），并提供获取该实例的全局访问点（必须是静态方法） 解决什么问题： 对象的唯一性 节省系统资源 项目中使用： 需要频繁创建和销毁的对象 创建对象耗时长，耗费资源多，但又经常用到的对象 频繁访问的数据库或文件对象 工具类对象 模式结构： 饿汉模式代码 12345678910111213141516/** * @author Damon-zln * @date 2019/2/17 17:27 * @description HungrySingleton * @update */public class HungrySingleton &#123; private static HungrySingleton hungrySingleton = new HungrySingleton(); private HungrySingleton() &#123;&#125; public static HungrySingleton getInstance() &#123; return hungrySingleton; &#125;&#125; 懒汉模式代码 12345678910111213141516171819/** * @author Damon-zln * @date 2019/2/17 17:31 * @description LazySingleton * @update */public class LazySingleton &#123; private static LazySingleton lazySingleton = null; private LazySingleton() &#123;&#125; public static synchronized LazySingleton getInstance() &#123; if (lazySingleton == null) &#123; lazySingleton = new LazySingleton(); &#125; return lazySingleton; &#125;&#125; 双重检查代码 1234567891011121314151617181920212223/** * @author Damon-zln * @date 2019/2/17 17:33 * @description DoubleCheckSingleton * @update */public class DoubleCheckSingleton &#123; private static volatile DoubleCheckSingleton doubleCheckSingleton = null; private DoubleCheckSingleton() &#123;&#125; public static DoubleCheckSingleton getInstance() &#123; if (doubleCheckSingleton == null) &#123; synchronized (DoubleCheckSingleton.class) &#123; if (doubleCheckSingleton == null) &#123; doubleCheckSingleton = new DoubleCheckSingleton(); &#125; &#125; &#125; return doubleCheckSingleton; &#125;&#125; 2. 工厂模式（简单的） 总结：使用方法代替new关键字来创建对象 解决什么问题： 解耦，将对象的创建和使用的过程分开 降低代码的重复 减少使用者因为对象的创建逻辑导致的错误 项目中使用： 对象的创建/实例化准备工作复杂，需要初始化的参数多 父子类的调用或在业务中易发生改变的对象 模式结构：写一个对外声明的方法，方法里面使用new关键字代替 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package per.dazhan.example;/** * @author Damon-zln * @date 2019/2/17 20:47 * @description Human 产品的抽象接口 人类 * @update */public interface Human &#123; void say();&#125;-------------------------------------------------------------------------------package per.dazhan.example;/** * @author Damon-zln * @date 2019/2/17 20:49 * @description Man 男人 * @update */public class Man implements Human &#123; @Override public void say() &#123; System.out.println("男人"); &#125;&#125;-------------------------------------------------------------------------------package per.dazhan.example;/** * @author Damon-zln * @date 2019/2/17 20:50 * @description Woman 女人 * @update */public class Woman implements Human &#123; @Override public void say() &#123; System.out.println("女人"); &#125;&#125;-------------------------------------------------------------------------------package per.dazhan.example;/** * @author Damon-zln * @date 2019/2/17 20:52 * @description SampleFactory 工厂类 * @update */public class SampleFactory &#123; public static Human makeHuman(String type) &#123; if ("man".equals(type)) &#123; Human man = new Man(); return man; &#125; else if ("woman".equals(type)) &#123; Human woman = new Woman(); return woman; &#125; else &#123; System.out.println("无法生产"); return null; &#125; &#125;&#125;-------------------------------------------------------------------------------package per.dazhan.example;/** * @author Damon-zln * @date 2019/2/17 20:56 * @description Client 工厂生产测试 * @update */public class Client &#123; public static void main(String[] args) &#123; Human man = SampleFactory.makeHuman("man"); man.say(); Human woman = SampleFactory.makeHuman("woman"); woman.say(); &#125;&#125; 3. 代理模式 总结：通过代理类，控制其他对象对当前对象的访问 解决什么问题： 不能直接访问某对象 开销大的对象 项目中使用： 控制访问权限 对大对象的访问权限 模式结构：代理类和被代理类实现同一个接口，用户访问的时候先访问代理对象，然后让代理对象去访问被代理对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package per.dazhan.example;/** * @author Damon-zln * @date 2019/2/17 21:14 * @description People 服务类接口 * @update */public interface People &#123; void Quanli();&#125;-----------------------------------------------------------------------------package per.dazhan.example;/** * @author Damon-zln * @date 2019/2/17 21:17 * @description Mayun 被代理的类 * @update */public class Mayun implements People &#123; public void eat() &#123; System.out.println("满汉全席"); &#125; public void sing() &#123; System.out.println("唱K"); &#125; @Override public void Quanli() &#123; System.out.println("机票"); &#125;&#125;---------------------------------------------------------------------------package per.dazhan.example;/** * @author Damon-zln * @date 2019/2/17 21:21 * @description Lvshi 代理类 * @update */public class Lvshi implements People &#123; @Override public void Quanli() &#123; new Mayun().Quanli(); &#125;&#125;-------------------------------------------------------------------------package per.dazhan.example;/** * @author Damon-zln * @date 2019/2/17 21:24 * @description Person * @update */public class Person &#123; public static void main(String[] args) &#123; People person = new Lvshi(); person.Quanli(); &#125;&#125; 4. 策略模式 总结：定义一些列算法，并可以相互替换（条条大路通罗马的意思） 解决什么问题： 同一件事可以有多种方法选择 项目中使用： 购物车的付款方式 模式结构：声明一个顶级接口，定义一个策略方法，具体的实例都要实现这个接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package per.dazhan.example;/** * @author Damon-zln * @date 2019/2/17 21:48 * @description Cart 购物车 * @update */public interface Cart &#123; void pay();&#125;-------------------------------------------------------------------------------package per.dazhan.example;/** * @author Damon-zln * @date 2019/2/17 21:50 * @description WeChat * @update */public class WeChat implements Cart &#123; @Override public void pay() &#123; System.out.println("微信支付"); &#125;&#125;-----------------------------------------------------------------------------package per.dazhan.example;/** * @author Damon-zln * @date 2019/2/17 21:51 * @description Alipay * @update */public class Alipay implements Cart &#123; @Override public void pay() &#123; System.out.println("支付宝支付"); &#125;&#125;-----------------------------------------------------------------------------package per.dazhan.example;/** * @author Damon-zln * @date 2019/2/17 21:51 * @description BankCard * @update */public class BankCard implements Cart &#123; @Override public void pay() &#123; System.out.println("银行卡支付"); &#125;&#125;----------------------------------------------------------------------------package per.dazhan.example;/** * @author Damon-zln * @date 2019/2/17 21:52 * @description Test * @update */public class Test &#123; public static void main(String[] args) &#123; Cart weChat = new WeChat(); Cart alipay = new Alipay(); Cart bankCard = new BankCard(); weChat.pay(); alipay.pay(); bankCard.pay(); &#125;&#125; 5. 模板模式 总结：父类定义流程，子类实现流程 解决什么问题： 业务千变万化，但是流程是有规定的 项目中使用： 基类的实现都是模板模式，如：BaseDao、BaseService 模式结构：定义一个抽象父类定义流程，或者常用方法和常量，子类继承父类，实现具体的细节方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package per.dazhan.example;/** * @author Damon-zln * @date 2019/2/17 22:05 * @description School * @update */public abstract class School &#123; public void regulation() &#123; selfStudy(); classBegin(); noonBreak(); examination(); leaveSchool(); &#125; protected abstract void selfStudy(); protected abstract void classBegin(); protected abstract void noonBreak(); protected abstract void examination(); protected abstract void leaveSchool();&#125;--------------------------------------------------------------------------package per.dazhan.example;/** * @author Damon-zln * @date 2019/2/17 22:11 * @description StudentA * @update */public class StudentA extends School &#123; @Override protected void selfStudy() &#123; System.out.println("selfStudy()"); &#125; @Override protected void classBegin() &#123; System.out.println("classBegin()"); &#125; @Override protected void noonBreak() &#123; System.out.println("noonBreak()"); &#125; @Override protected void examination() &#123; System.out.println("examination()"); &#125; @Override protected void leaveSchool() &#123; System.out.println("leaveSchool()"); &#125;&#125;-------------------------------------------------------------------------package per.dazhan.example;/** * @author Damon-zln * @date 2019/2/17 22:13 * @description StudentB * @update */public class StudentB extends School &#123; @Override protected void selfStudy() &#123; System.out.println("selfStudy()"); &#125; @Override protected void classBegin() &#123; System.out.println("classBegin()"); &#125; @Override protected void noonBreak() &#123; System.out.println("noonBreak()"); &#125; @Override protected void examination() &#123; System.out.println("examination()"); &#125; @Override protected void leaveSchool() &#123; System.out.println("leaveSchool()"); &#125;&#125; ​]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java类初始化顺序]]></title>
    <url>%2F2019%2F02%2F17%2Fjava%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Java类中的初始化顺序 静态属性 静态代码块 普通属性（非静态） 普通代码块（非静态） 构造函数 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package per.dazhan.example;/** * @author Damon-zln * @date 2019/2/17 14:15 * @description demo1 * @update */public class demo1 &#123; /** * java类中的初始化顺序 * 1. 静态属性: 带有static关键字定义的属性 * 2. 静态代码块: static&#123;&#125; * 3. 普通属性: 不带static关键字定义的属性 * 4. 普通代码块: &#123;&#125; * 5. 构造函数: 与类名一样的方法 * 6. 方法: 普通方法 * @param args */ public static void main(String[] args) &#123; new A(); &#125;&#125;class A &#123; // 静态属性 private static String staticField = getStaticField(); // 普通属性 private String field = getField(); // 静态代码块 static &#123; System.out.println("静态方法块初始化----2"); &#125; // 普通代码块 &#123; System.out.println("普通方法块初始化----4"); &#125; // 构造函数 public A() &#123; System.out.println("构造函数初始化----5"); &#125; private static String getStaticField() &#123; String staticField = "staticField"; System.out.println("静态属性初始化----1"); return staticField; &#125; private String getField() &#123; String field = "field"; System.out.println("普通属性初始化----3"); return field; &#125;&#125;=================================================================================执行结果：静态属性初始化----1静态方法块初始化----2普通属性初始化----3普通方法块初始化----4构造函数初始化----5Process finished with exit code 0 父类与子类 （普通类） 父类 （如上） 继承的子类 父类静态属性 父类静态代码块 子类静态属性 子类静态代码块 父类普通属性 父类普通代码块 父类构造函数 子类普通属性 子类普通代码块 子类构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class B extends A &#123; // 静态属性 private static String staticField = getStaticField(); // 普通属性 private String field = getField(); // 静态代码块 static &#123; System.out.println("子类--静态方法块初始化----2"); &#125; // 普通代码块 &#123; System.out.println("子类--普通方法块初始化----4"); &#125; public B() &#123; super(); System.out.println("子类--构造函数初始化----5"); &#125; private static String getStaticField() &#123; String staticField = "staticField"; System.out.println("子类--静态属性初始化----1"); return staticField; &#125; private String getField() &#123; String field = "field"; System.out.println("子类--普通属性初始化----3"); return field; &#125;&#125;=========================================================================main方法执行new B（）；执行结果：静态属性初始化----1静态方法块初始化----2子类--静态属性初始化----1子类--静态方法块初始化----2普通属性初始化----3普通方法块初始化----4构造函数初始化----5子类--普通属性初始化----3子类--普通方法块初始化----4子类--构造函数初始化----5Process finished with exit code 0 接口-抽象类-实现类 接口静态变量 抽象类静态变量 抽象类静态代码块 实现类静态变量 实现类静态代码块 抽象类普通变量 抽象类普通代码块 抽象类构造函数 实现类普通变量 实现类普通代码块 实现类构造函数 注意： 接口中声明的变量都是final，必须实例化，子类无法修改，固定值 接口中可以有静态方法，不能有普通方法，普通方法需要用default添加默认实现 接口中没有静态代码块、普通变量、普通代码块、构造函数]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装数据库]]></title>
    <url>%2F2019%2F01%2F24%2Fdocker%E5%AE%89%E8%A3%85%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[1. docker安装mysql5.7 查看镜像 docker search mysql 拉取镜像 docker pull mysql:5.7 运行镜像 docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 参数说明： 12345-d 标识是让 docker 容器在后台运行。-p 标识通知 Docker 将容器内部使用的网络端口映射到我们使用的主机上。–name 定义一个容器的名字，如果在执行docker run时没有指定Name，那么deamon会自动生成一个随机数字符串当做UUID。-e 设置环境变量，或者覆盖已存在的环境变量3306:3306 将容器的3306端口映射到本机的3306端口 (左边是宿主机端口，右边是容器内端口) 使用脚本 + crontab 方式定期备份运行在主机docker 容器内部数据 备份脚本： 1234567891011121314151617181920212223#!/bin/bash# author: Damon Zhang# description: back up web_scrape database weeklydocker exec -i mysql bash &lt;&lt; 'EOF'rm web_scrape_*mysqldump -uroot -proot web_scrape &gt; web_scrape_$(date +%Y_%m_%d).sqlexitEOFbasepath=$(cd `dirname $0`; pwd)/mysqlif [ ! -d "$basepath" ]; then mkdir $basepathfidocker cp mysql:/web_scrape_$(date +%Y_%m_%d).sql $basepathgzip $basepath/web_scrape_$(date +%Y_%m_%d).sql 添加crontab任务： 1234crontab -e# 每周日早上6点备份数据库0 6 * * 0 . /etc/profile; /bin/sh /home/damon.zhang/backup/mysql_backup.sh 注： 注意一定要添加“ . /etc/profile;” ，这句用于将环境变量include进当前脚本的执行环境 /home/damon.zhang/backup/mysql_backup.sh 这个是脚本的绝对路径 重启crontabd服务： 1service crond restart 2. docker安装redis 查看镜像 docker search redis 拉取镜像 docker pull redis 运行镜像 docker run --name redis -p 6379:6379 -d --restart=always redis:latest redis-server --appendonly yes --requirepass &quot;foobared&quot; 参数说明： 123456-p 6379:6379 :将容器内端口映射到宿主机端口（左边是宿主机端口，右边是容器内端口）redis-server –appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置 --requirepass “your passwd” :设置认证密码 –-restart=always : 随docker启动而启动--name redis ：指定容器的名字-d : 后台运行]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>mysql</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用命令总结]]></title>
    <url>%2F2018%2F12%2F21%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1. 从一个文件中抽取出包含指定字段的行，并保存到新文件awk &#39;BEGIN{FS=&quot;|&quot;;OFS=&quot;|&quot;} NR==FNR{a[$1]=$1} NR&gt;FNR{if ($9 in a) print $0}&#39; file1 file2 &gt; file3 注：将指定的字段写到file1文件（如果有多个指定字段，一行写一个），file2是要抽取的文件 2. 格式化文件，将文件每N行合并为一行 （该命令是每19行合并为一行）awk &#39;{ printf &quot;%s&quot;, $0; if (NR % 19 == 0) print &quot;&quot;; else printf &quot;|&quot; }&#39; value.txt &gt;&gt; all.txt 3. 统计文件中重复记录数awk &#39;BEGIN{FS=&quot;|&quot;;OFS=&quot;|&quot;} {a[$0]++} END{for(i in a){print a[i],i}}&#39; file.txt &gt; newName.txt 4. 去除文件中重复的记录awk &#39;!a[$0]++&#39; filename &gt; newFilename 5. txt转csvcat test.txt | tr &quot;[[:space:]]&quot; &quot;\t&quot; &gt;test.csv 注：cat test.txt | tr &quot;old value&quot; &quot;new value&quot; &gt; test.csv 6. Kill掉指定名称的进程ps -ef | grep -w &#39;nameprocess&#39; | grep -v grep | cut -c 10-14 | xargs kill -9 12345“ps -ef”是查看所有进程的命令。这时检索出的进程将作为下一条命令“grep“的输入，注意要结束其它程序时，请将上面命令中的nameprocess替换成其它程序名，-w &apos;nameprocess&apos; 强制 PATTERN 仅完全匹配字词。 “grep -v grep”是在列出的进程中去除含有关键字“grep”的进程。 “cut -c 10-14”是截取输入行的第10个字符到第14个字符，而这正好是进程号PID，或者根据自己实际的情况可以调整字符的截取位置。 “xargs kill -9”中的xargs命令是用来把前面命令的输出结果（PID）作为“kill -9”命令的参数，并执行该命令。 “kill -9”会强行杀掉指定进程，这样就成功清除了同名进程。 7. ps -ef | grep 详解1234567891011121314151617181920ps命令将某个进程显示出来 grep命令是查找 中间的|是管道命令 是指ps命令与grep同时执行 PS是LINUX下最常用的也是非常强大的进程查看命令 grep命令是查找，是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。 以下这条命令是检查java 进程是否存在：ps -ef |grep java 字段含义如下： --------------------------------------------------------------------------------------------UID PID PPID C STIME TTY TIME CMD zzw 14124 13991 0 00:38 pts/0 00:00:00 grep --color=auto dae--------------------------------------------------------------------------------------------UID ：程序被该 UID 所拥有 PID ：就是这个程序的 ID PPID ：则是其上级父程序的ID C ：CPU使用的资源百分比 STIME ：系统启动时间 TTY ：登入者的终端机位置 TIME ：使用掉的CPU时间。 CMD ：所下达的是什么指令]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[执行docker命令遇到 Get Permission Denied]]></title>
    <url>%2F2018%2F11%2F13%2Fdocker%E5%91%BD%E4%BB%A4%E9%81%87%E5%88%B0Permission%20Denied%2F</url>
    <content type="text"><![CDATA[执行docker命令遇到 Get Permission Denied 安装完docker后，执行docker相关命令，出现： 1Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.37/images/json: dial unix /var/run/docker.sock: connect: permission denied 原因： 摘自dockermannual上的一段话 12345Manage Docker as a non-root userThe docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can only access it using sudo. The docker daemon always runs as the root user.If you don’t want to use sudo when you use the docker command, create a Unix group called docker and add users to it. When the docker daemon starts, it makes the ownership of the Unix socket read/writable by the docker group. 大概的意思就是：docker进程使用Unix Socket而不是TCP端口。而默认情况下，Unix socket属于root用户，需要root权限才能访问。 解决方法1： 使用sudo获取管理员权限，运行docker命令 解决方法2： docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，因此只要创建docker用户组，并将当前用户加入到docker用户组中，那么当前用户就有权限访问Unix socket了，进而也就可以执行docker相关命令 1234sudo groupadd docker #添加docker用户组sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中newgrp docker #更新用户组docker ps #测试docker命令是否可以正常使用]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令遇到的问题总结]]></title>
    <url>%2F2018%2F11%2F13%2FLinux%E5%91%BD%E4%BB%A4%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1. root用户和sudo使用root权限的区别： 功能：以root的身份执行命令 语法：sudo 其他指令 用户：被root加入/etc/sudoers文件中的用户 区别：普通用户使用sudo来执行只有root才能执行权限的命令，跟root用户执行是不一样的，因为这时候他用的还是普通用户的环境变量 2. linux给用户添加sudo权限： linux下直接运行sudo命令，会提示： 1xxxx is not in the sudoers file. This incident will be reported. 这里，xxxx是用户名称，这条信息表明无法执行sudo命令，解决如下： 进入超级用户模式。也就是输入su - ，系统会让你输入超级用户密码，输入后就进入了超级用户模式。（当然你可以直接使用root登录） 编辑/etc/sudoers文件。也就是输入命令vim /etc/sudoers进入编辑模式，找到这一行：root ALL=(ALL) ALL在下面添加xxx ALL=(ALL) ALL（这里的xxx是你的用户名），然后保存退出即可。 3. linux中drwxr-xr-x的意思和权限： 读（read），写（write），执行（recute），简写（r，w，x），用数字表示（4，2，1） | 权限项 | 读 | 写 | 执行 | 读 | 写 | 执行 | 读 | 写 | 执行 || :——- | :—-: | :—-: | :—-: | :—-: | :—-: | :—-: | :——: | :——: | :——: || 字符表示 | r | w | x | r | w | x | r | w | x || 数字表示 | 4 | 2 | 1 | 4 | 2 | 1 | 4 | 2 | 1 || 权限分配 | 所有者 | 所有者 | 所有者 | 所属组 | 所属组 | 所属组 | 其他用户 | 其他用户 | 其他用户 | 举例： 若某文件的权限为7（4+2+1），则代表可读（4）、可写（2）、可执行（1）。 若某文件的权限为6（4+2），则表示可读（4）、可写（2）。 若某文件的权限为5（4+1），则表示可读（4）、可执行（1）。 若某文件的权限为3（2+1），则表示可写（2）、可执行（1）。 若没有对文件的任何权限，用数字0表示。 12[dazhan@iZuf6ic9ggky8lupefuf5xZ etc]$ ll adjtime-rw-r--r--. 1 root root 18 Aug 18 2017 adjtime 上述命令中，文件所有者为root，所属组root，文件名adjtime，文件权限为644。 -rw-r--r-- 第一位代表文件类型：-:普通文件，d:目录文件，l:链接文件，b:设备文件，c:字符设备文件，p:管道文件 权限： 用户权限，就是你自己的权限。英文：user，简写：u 用户组权限，就是和你同组的人的权限。英文：group，简写：g 其他权限，就是不和你同组的人的权限。英文：others，简写：o chmod 命令是用于改变文件或目录的访问权限。 +表示增加权限，如u+x, u+r, u+w, g+w, g+r, o+r， a+r等 -表示取消权限，如u-x, u-r, u-w, g-w, g-r, o-r， a-r等 =表示赋予给定权限，并取消其他所有权限（如果有的话，如原来u是rwx，设置u=r，u就剩r） 4. 修改主机名和是否显示完整的主机名 查看当前主机名：hostname 主机名保存在/etc/hostname文件里，所以只要编辑这个文件即可，将原来的主机名替换为自己想要的主机名。 更新/etc/hosts文件，因为主机名已经更改，如果不更新这个文件，有的程序不知道如何解析新的主机名，如sudo。将其中的localhost.localdomain 修改为新的主机名。 1127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 修改完成之后重启服务器：reboot 重启完成后，假设新的主机名是example10.201.10.11，发现没有显示完整的主机名，如下： 1[dazhan@example10 ~]$ 如要显示完整的主机名，解决方法如下： 找到~/.bashrc里面的export PS1=&quot;[\u@\h \W]\$ &quot;这一行，如果没有就添加，只需要将h改为H，然后保存文件，并使用source ~/.bashrc命令使之立即加载生效。 特殊符号的意义： \H完整的主机名称。例如：我的机器名称为：example10.201.10.11，则这个名称就是example10.201.10.11 \h仅取主机的第一个名字，如上例，则为example10，.201.10.11则被省略 \w完整的工作目录名称。家目录会以 ~代替 \W利用basename取得工作目录名称，所以只会列出最后一个目录 \u当前用户的账号名称 \$提示字符，如果是root时，提示符为：# ，普通用户则为：$]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell脚本中遇到的问题及解决方案]]></title>
    <url>%2F2018%2F10%2F19%2Fshell%E8%84%9A%E6%9C%AC%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[1. ||运算符 问题场景：shell脚本中定义了一个方法，方法里面有一个for循环，依次请求10个服务器并将结果保存到文件。试想，如果其中一个服务器的地址写错了，shell脚本执行到这里就会中断，不会继续往下执行了。 解决方案： 第一种方法，就是使用if判断，这个在这里不细说。 第二种方法是使用||运算符。 command1 || command2，如果command1未执行成功，那么就执行command2 这样，我们在循环中请求服务器的代码就可以写成如下形式： 1curl --max-time 120 --user $&#123;user&#125;:$&#123;pwd&#125; -s -k --request POST --header "Content-type: text/xml; charset=utf-8" --data @$&#123;requestFile&#125; $&#123;url&#125; | iconv -t utf8 | xmllint --format - &gt; $&#123;responseFile&#125; || true 只需要保证|| 右边的command2为真就可以了，当然你也可以写成i=1 这种为真的等式，但是不推荐这么做，因为这样在别人看代码的时候，会造成误解。 2. 关于getopts的使用方法 例子： 123456789101112131415161718192021222324252627282930while getopts ":e:s:pd:l" arg; do case $arg in e) ghs_env=$OPTARG ;; s) ghs_service=$OPTARG ;; p) proxy=`sed '/^PROXY=/!d;s/.*=//' config.properties` ;; d) dir_path=$OPTARG ;; l) if [ -d "log" ]; then rm -r log mkdir log else mkdir log fi log_dir=$(cd `dirname $0`; pwd)/log ;; ?) echo "Usage: $(basename $0) [-e somevalue] [-s somevalue] [-p somevalue] [-d somevalue]" 1&gt;&amp;2 exit 1 ;; esacdone getopts有两个参数，第一个参数是一个字符串，包括字符和” : “, 每一个字符都是一个有效的选项，如果字符后面带有” : “, 表示这个字符有自己的参数。getopts从命令中获取这些参数，并且删去了” - “, 并将其赋值在第二个参数中，即”OPTARG“中，在例子中，$OPTARG存储相应选项的参数。 while getopts &quot;:e:s:pd:l&quot; arg; 这行代码中，第一个冒号表示忽略系统报错信息，使用自定义的报错信息；字符后面的冒号表示该选项必须自己的参数。 第一个冒号存在时（自定义报错信息）： 当指定的参数不存在时，variable设置为” : “, 对应的$OPTARG为此时的选项 （这个尚未搞明白是什么意思） 当指定的选项是带参数的而没有提供参数或是非法选项（指定的选项没有定义），variable设置为” ? “, 对应的$OPTARG为此时的选项 第一个冒号不存在时（会按照系统的定义报错）： 指定了非法选项（不存在的选项或者说是没有定义的选项），会报错：scriptname:illegal option — 选项 选项需要参数但没有指定，会报错：scriptname: option requires an argument –选项 单个字符后面接一个冒号，表示选项必须自己的参数，参数可以紧跟选项后或者以空格隔开，该参数的指针赋给OPTARG。 单个字符后面接两个冒号表示该选项必须自己的参数且参数紧跟选项后不能以空格隔开（我试过，感觉有没有空格都可以，因此，我觉得如果要加参数，字符后只要写一个冒号就可以了），该参数的指针赋给OPTARG。]]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql数据导出提示--secure-file-priv的问题]]></title>
    <url>%2F2018%2F10%2F19%2Fmysql%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA%E6%8F%90%E7%A4%BA--secure-file-priv%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Mysql数据导出提示–secure-file-priv的问题 mysql可使用into outfile参数把表中的数据到处到csv，示例如下： 1select user_id from weibo_comment into outfile &apos;/home/dazhan/comment.csv&apos; lines terminated by &apos;\n&apos;; 执行后，weibo_comment表中的user_id字段就会被导出/home/dazhan/comment.csv 参数说明： into outfile导出的目录和文件名 指定导出的目录和文件名 fields terminated by字段间分隔符 定义字段间的分隔符 optionally enclosed by字段包围符 定义包围字段的字符（数值型字段无效） lines terminated by行间分隔符 定义每行的分隔符 问题分析： 以上实例在实际的运行中出现如下错误： 12mysql&gt; select user_id from weibo_comment into outfile &apos;/home/dazhan/comment.txt&apos; lines terminated by &apos;\n&apos;;ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement 查看官方文档，--secure-file-priv参数用于LOAD DATA, SELECT …OUTFILE, LOAD_FILE()传到哪个指定目录。 secure-file-priv为NULL时，表示限制mysqld不允许导入或导出。 secure-file-priv为/var/lib/mysql-files/时，表示限制mysqld只能在/var/lib/mysql-files/目录中执行导入导出，其他目录不行。 secure-file-priv没有值时，表示不限制mysqld在任意目录的导入导出。 查看secure-file-priv的值（默认值是NULL）的命令如下： 1234567mysql&gt; show global variables like &apos;%secure_file_priv%&apos;;+------------------+-----------------------+| Variable_name | Value |+------------------+-----------------------+| secure_file_priv | /var/lib/mysql-files/ |+------------------+-----------------------+1 row in set (0.01 sec) 这是我的查询结果，所以，我只需要把上述的输出目录改为/var/lib/mysql-files/就可以进行数据导出。 修改secure-file-priv参数值的方法： 打开my.cnf或my.ini，加入如下语句后重启mysql服务。 1secure_file_priv=&apos;&apos; 查看修改后的值： 1234567mysql&gt; show global variables like &apos;%secure_file_priv%&apos;;+------------------+-------+| Variable_name | Value |+------------------+-------+| secure_file_priv | |+------------------+-------+1 row in set (0.01 sec) 这样修改后，就可以在任意目录进行数据导入导出了。]]></content>
      <categories>
        <category>Mysql笔记</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK开发环境配置]]></title>
    <url>%2F2018%2F10%2F15%2FJDK%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[JDK开发环境配置1. 新建 -&gt; 变量名“JAVA_HOME”, 变量值“C:\Program Files\Java\jdk1.8.0_112”（即JDK的安装路径）2. 编辑 -&gt; 变量名“Path”, 在原变量值的最后加上“;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin”3. 新建 -&gt; 变量名“CLASSPATH”, 变量值“.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar”4. 测试： 在CMD中分别输入java,javac,java -version命令，出现JDK的编译信息，包括修改命令的语法和参数选项的信息，即环境配置成功。]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 指定文件夹下所有文件（包括子目录下的文件）拷贝到目标文件夹下]]></title>
    <url>%2F2018%2F09%2F17%2F%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[1. Python3 指定文件夹下所有文件（包括子目录下的文件）拷贝到目标文件夹下1234567891011121314151617181920212223242526#!/usr/bin/env python3# -*- coding:utf8 -*-# @TIME :2018/9/17 9:02# @Author:dazhan# @File :copyfiles2dir.pyimport osimport shutilsource_path = os.path.abspath(r'Z:\webscraping\output\dazhan_group_WS1810222337649')target_path = os.path.abspath(r'D:\Weekly_Refresh\needToCheck')if not os.path.exists(target_path): os.makedirs(target_path)if os.path.exists(source_path): # root 所指的是当前正在遍历的这个文件夹的本身的地址 # dirs 是一个 list，内容是该文件夹中所有的目录的名字(不包括子目录) # files 同样是 list, 内容是该文件夹中所有的文件(不包括子目录) for root, dirs, files in os.walk(source_path): for file in files: src_file = os.path.join(root, file) shutil.copy(src_file, target_path) print(src_file)print('copy files finished!')]]></content>
      <categories>
        <category>Python3笔记</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy+Scrapy-redis+Scrapyd+Gerapy分布式爬虫框架整合]]></title>
    <url>%2F2018%2F09%2F07%2FScrapy-Scrapy-redis-Scrapyd-Gerapy%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[前言首先，介绍一下这个标题吧。 Scrapy：是一个基于Twisted的异步IO框架，有了这个框架，我们就不需要等待当前URL抓取完毕之后在进行下一个URL的抓取，抓取效率可以提高很多。 Scrapy-redis：虽然Scrapy框架是异步加多线程的，由于我们只能在一台主机上运行，爬取效率还是有限的，Scrapy-redis库为我们提供了Scrapy分布式的队列，调度器，去重等等功能，有了它，我们就可以将多台主机组合起来，共同完成一个爬取任务，抓取的效率又提高了。 Scrapyd：分布式爬虫完成之后，接下来就是代码部署，如果我们有很多主机，那就要逐个登录服务器进行部署，万一代码有所改动……….可以想象，这个过程是多么繁琐。Scrapyd是专门用来进行分布式部署的工具，它提供HTTP接口来帮助我们部署，启动，停止，删除爬虫程序，利用它我们可以很方便的完成Scrapy爬虫项目的部署。 Gerapy：是一个基于Scrapyd，Scrapyd API，Django，Vue.js搭建的分布式爬虫管理框架。简单点说，就是用上述的Scrapyd工具是在命令行进行操作，而Gerapy将命令行和图形界面进行了对接，我们只需要点击按钮就可完成部署，启动，停止，删除的操作。 创建Scrapy项目（参考Scrapy框架入门） 项目结构如下（这个项目里包含了多个spider，接下来，就以我圈出来的为例讲解） 因为我这个需要用到固定的代理，在这个讲一下代理如何使用： 代理在middlewares.py这个模块中的process_request方法中进行配置（如果想知道为什么在这里配置，可以去google一下scrapy框架爬虫的整体结构流程），如下： 123456789101112class ProxyMiddleware(object): def __init__(self, proxy_url): self.proxy_url = proxy_url def process_request(self, request, spider): request.meta['proxy'] = self.proxy_url @classmethod def from_crawler(cls, crawler): return cls( proxy_url=crawler.settings.get('PROXY_URL') ) 然后在settings.py中指定具体的代理是什么,如下： 1PROXY_URL = 'http://10.51.1.140:8080' 如果要设置动态代理，参考这里：https://github.com/Damon-zln/ProxyPool Scrapy-redis分布式配置 首先，确认Scrapy-redis库已经安装，如果未安装，可以 pip install scrapy-redis 进行安装。 搭建Redis服务器，如果未安装redis数据库的，请自行google。 Redis安装完成后，就可以远程连接了，如果不能，可能是服务器上没有开放端口（redis默认端口6379） 记录服务器的IP，端口（默认是6379），密码为foobared（安装的时候自己设置的密码），供后面分布式爬虫使用。 配置Scrapy-redis（只需要修改settings.py文件即可） 将调度器的类和去重的类替换为Scrapy-redis提供的类，在settings.py中配置如下： 12SCHEDULER = 'scrapy_redis.scheduler.Scheduler'DUPEFILTER_CLASS = 'scrapy_redis.dupefilter.RFPDupeFilter' Redis连接配置： 1REDIS_URL = 'redis://:foobared@10.255.1.175:6379' 其他的都使用默认配置（如：调度对列，持久化，重爬，管道） 配置存储目标： 搭建一个MongoDB服务，将多台主机的数据都存在同一个MongoDB数据库中 配置如下： 12MONGO_URI = '10.255.1.175'MONGO_DB = 'webscrape' 综上，分布式完整配置如下： 123456MONGO_URI = '10.255.1.175'MONGO_DB = 'webscrape'PROXY_URL = 'http://10.51.1.140:8080'SCHEDULER = 'scrapy_redis.scheduler.Scheduler'DUPEFILTER_CLASS = 'scrapy_redis.dupefilter.RFPDupeFilter'REDIS_URL = 'redis://:foobared@10.255.1.175:6379' Scrapyd安装 安装：pip install scrapyd 配置：安装完毕后，需要新建一个配置文件/etc/scrapyd/scrapyd.conf，scrapyd在运行时会读取此配置文件 在Scrapyd1.2版本后，不会自动创建该文件，需要我们自行添加。 首先，执行如下命令新建文件： 12sudo mkdir /etc/scrapydsudo vi /etc/scrapyd/scrapyd.conf 然后在文件中写入如下内容： 1234567891011121314151617181920212223242526272829[scrapyd]eggs_dir = eggslogs_dir = logsitems_dir =jobs_to_keep = 5dbs_dir = dbsmax_proc = 0max_proc_per_cpu = 4finished_to_keep = 100poll_interval = 5.0bind_address = 127.0.0.1http_port = 6800debug = offrunner = scrapyd.runnerapplication = scrapyd.app.applicationlauncher = scrapyd.launcher.Launcherwebroot = scrapyd.website.Root[services]schedule.json = scrapyd.webservice.Schedulecancel.json = scrapyd.webservice.Canceladdversion.json = scrapyd.webservice.AddVersionlistprojects.json = scrapyd.webservice.ListProjectslistversions.json = scrapyd.webservice.ListVersionslistspiders.json = scrapyd.webservice.ListSpidersdelproject.json = scrapyd.webservice.DeleteProjectdelversion.json = scrapyd.webservice.DeleteVersionlistjobs.json = scrapyd.webservice.ListJobsdaemonstatus.json = scrapyd.webservice.DaemonStatus 该内容参见官方文档：https://scrapyd.readthedocs.io/en/stable/config.html#example-configuration-file 这里的配置文件有所修改：max_proc_per_cpu官方默认是4，即一台主机每个CPU最多运行4个Scrapy任务，在此提高为10，另外，bind_address，默认为本地127.0.0.1，在此修改为0.0.0.0,这样外网可以访问。 后台运行scrapyd 1scrapyd &gt; /dev/null &amp; 运行之后，便可在浏览器的6800端口访问WEB UI了，如下： Gerapy分布式管理 安装：pip install gerapy 使用说明： 利用gerapy命令创建一个项目 1gerapy init 在当前目录下生成一个gerapy文件夹，进入gerapy文件夹，会发现一个空的projects文件夹，后面后用到. 初始化： 1gerapy migrate 这样会生成一个SQLite数据库，用于保存各个主机的配置信息等. 启动Gerapy服务: 1gerapy runserver host:port (默认端口是8000) 这样，我们就可以通过http://host:8000进入Gerapy管理页面 在主机管理中添加安装了Scrapyd环境的机器（机器IP和Scrapyd运行的端口，默认是6800），如下图： 上面创建gerapy项目的时候，会生成一个projects文件夹，这个文件夹就是用来存放你的Scrapy项目的（直接将整个项目拷贝到这个文件夹下即可） 可以点击上图中的编辑，在线编辑项目，如果项目没有问题，可以点击部署进行打包和部署，在部署之前要打包项目（打包成一个egg文件），可以部署到多台主机，如下所示： 部署完毕后，可以回到主机管理页面进行任务调度。点击调度即可进入任务管理页面，可以查看当前主机所有任务的运行状态。 通过点击运行，停止按钮来实现任务的启动和停止，同时可以展开任务条目查看日志详情。 下面是抓取的数据存入MongoDB数据库。 Docker部署在讲docker部署之前，先简单总结一下上面我们做了什么事吧。 创建Scrapy项目：里面存放的就是抓取数据的一些逻辑 Scrapy-redis分布式配置：这是是在Scrapy项目中的settings.py文件中配置的，作用就是让Scrapy支持分布式 Scrapyd安装：分布式抓取时，分布节点（node机器）所需要的环境 Gerapy分布式管理：这个就是类似于我们webscraping的管理平台 我们这里的docker部署，是指将我们的分布节点的scrapyd环境，使用docker来安装，具体如下： 首先在每台节点上安装docker（最新的稳定的版本） 执行docker命令完成环境安装：docker run --name scrapyd -p 6800:6800 -d damon7096/scrapyd:latest]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy框架入门]]></title>
    <url>%2F2018%2F07%2F18%2FScrapy%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1. 准备工作安装Scrapy框架、MongoDB和PyMongo库，如果没有安装，google了解一下~~ 2. 创建项目使用命令创建Scrapy项目，命令如下： scrapy startproject tutorial 该命令可以在任意文件夹运行，如果提示权限问题，可以加sudo运行。该命令会创建一个名为tutorial的文件夹，结构如下： scrapy.cfg： Scrapy项目的配置文件，定义了项目的配置文件路径，部署相关信息等 item.py： 定义item数据结构（爬取的数据结构） pipeline.py： 定义数据管道 settings.py： 配置文件e middlewares.py： 定义爬取时的中间件 spiders： 放置Spiders的文件夹 3. 创建Spider Spider是自己定义的类，Scrapy用它来从网页抓取内容，并解析抓取结果。该类必须继承Scrapy提供的Spider类scrapy.Spider。 使用命令创建一个Spider，命令如下： 12cd tutorialscrapy genspider quotes quotes.toscrape.com 首先，进入刚才创建的tutorial文件夹，然后执行genspider命令。第一个参数是spider的名称，第二个参数是网络域名（要抓取网络的域名）。执行完毕后，spiders文件夹中多了一个quotes.py，它就是刚刚创建的Spider，内容如下： 该类中有三个属性 —— name、allowed_domains、start_urls，一个方法parse。 name，唯一的名字，用来区分不同的Spider。 allowed_domains，允许爬取的域名，如果初始或后续的请求链接不是该域名下的，则被过滤掉。 start_urls，Spider在启动时爬取的url列表，用来定义初始的请求。 parse，它是spider的一个方法，用来处理start_urls里面的请求返回的响应，该方法负责解析返回的响应，提取数据或进一步生成处理的请求。 4. 创建ItemItem是保存爬取数据的容器，使用方法和字典类似。创建Item需要继承scrapy.Item类，并且定义类型为scrapy.Field的字段。 定义Item，将生成的items.py修改如下： 这里定义了三个字段，接下来爬取时我们会用到这个Item。 5. 解析Response前面我们看到，parse()方法的参数response是start_urls里面的链接爬取后的结果，所以在parse方法中，可以对response变量包含的内容进行解析。网页结构如下： 提取方式可以是CSS选择器或XPath选择器。在这里，使用CSS选择器，parse()方法修改如下： 123456def parse(self, response): quotes = response.css('.quote') for quote in quotes: text = quote.css('.text::text').extract_first() author = quote.css('.author::text').extract_first() tag = quote.css('.tags .tag::text').extract() 首先，利用选择器选取所有的quote，并将其赋值给quotes变量，然后利用for循环对每一个quote遍历，解析每一个quote的内容。 对text来说，他的class是text，所以用.text选择器来选取，这个结果实际上是整个带有标签的节点，要获取它的正文内容，可以加::text来获取。这时的结果是长度为1的列表，所以还需要用extract_first()方法来获取第一个元素。 6. 使用Item上面定义了Item，这边我们就需要用到它。Item可以理解为一个字典，不过在这里需要先实例化，然后将解析的结果赋值给Item的每一个字段，最后返回Item。 修改QuotesSpider类如下： 至此，首页的所有内容被解析出来了，并将结果赋值给一个个TutorialItem。 7. 后续Request上面实现了网页首页的抓取解析，那么下一页怎么抓取呢？我们可以看到网页的翻页结构如下： 这里有一个Next按钮，查看源码，可以看出下一页的全链接是：http://quotes.toscrape.com/page/2/,通过这个链接我们就可以构造下一个请求。 构造请求需要用到scrapy.Request。这里会有两个参数 ——-url和callback。 url，请求链接。 callback，回调函数。请求完毕后，获取响应，引擎会将该响应作为参数传递给回调函数，回调函数进行解析或生成下一个请求。 在parse()方法中追加如下代码： 123next_page = response.css('.pager .next a::attr("href")').extract_first()url = response.urljoin(next_page)yield scrapy.Request(url=url, callback=self.parse) 第一句，获取下一个页面的链接，即要获取a超链接中的href属性。 第二句，调用urljoin()方法，urljoin()方法可以将相对URL构造成一个绝对URL。例如，获取得到下一页的地址是/page/2/，urljoin()方法处理后的结果是：http://quotes.toscrape.com/page/2/。 第三句，通过url和callback变量构造了一个新的请求，回调函数callback依然使用parse()方法。这样，爬虫就进入了一个循环，直到最后一页。 修改之后，整个Spider类如下： 12345678910111213141516171819202122# -*- coding: utf-8 -*-import scrapyfrom tutorial.items import TutorialItemclass QuotesSpider(scrapy.Spider): name = 'quotes' allowed_domains = ['quotes.toscrape.com'] start_urls = ['http://quotes.toscrape.com/'] def parse(self, response): quotes = response.css('.quote') for quote in quotes: item = TutorialItem() item['text'] = quote.css('.text::text').extract_first() item['author'] = quote.css('.author::text').extract_first() item['tag'] = quote.css('.tags .tag::text').extract() yield item next_page = response.css('.pager .next a::attr("href")').extract_first() url = response.urljoin(next_page) yield scrapy.Request(url=url, callback=self.parse) 8. 运行进入目录，运行如下命令： scrapy crawl quotes 就可以看到Scrapy的运行结果了。 9. 保存文件运行完Scrapy后，我们只在控制台看到了输出结果。如何保存结果呢？ Scrapy提供了Feed Exports可以轻松将结果输出。例如，我们想将上面的结果保存成JSON文件，可以执行如下命令： scrapy crawl quotes -o quotes.json 命令运行后，会发现项目内多了一个quotes.json文件，这个文件包含了抓取的所有内容，格式为JSON。 另外，还支持其他格式如下： 123456scrapy crawl quotes -o quotes.jsonlines (scrapy crawl quotes -o quotes.jl , jl是jsonlines的缩写)scrapy crawl quotes -o quotes.csvscrapy crawl quotes -o quotes.xmlscrapy crawl quotes -o quotes.picklescrapy crawl quotes -o quotes.marshalscrapy crawl quotes -o ftp://user:pass@ftp.example.com/path/to/quotes.csv (远程输出，需要正确配置，否则会报错) 10. 使用Pipeline如果想进行复杂额操作，如将结果保存到MongoDB数据库，或者筛选Item，我们可以定义Pipeline来实现。 前面提到，Pipeline是项目管道，当Item生成后，它会自动被送到Pipeline进行处理，主要的操作如下： 清理HTML数据 验证爬取的数据，检查爬取的字段 查重并丢弃重复内容 将结果保存到数据库 实现Pipeline，只需要定义一个类并实现process_item()方法即可。启用Pipeline后，Pipline会自动调用这个方法。process_item()方法必须返回包含数据的字典或item对象，或者抛出DropItem异常。 process_item()方法有两个参数，一个参数是item，每次Spider生成的Item都会作为参数传递过来，另一个参数是spider，就是Spider的实例。 接下来，我们实现一个Pipline，筛掉text长度大于50的Item，并将结果保存到MongoDB数据库。 修改pipelines.py如下： 1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding: utf-8 -*-from scrapy.exceptions import DropItemimport pymongoclass TutorialPipeline(object): def __init__(self): self.limit = 50 def process_item(self, item, spider): if item['text']: if len(item['text']) &gt; self.limit: item['text'] = item['text'][0:self.limit].rstrip() + '...' return item else: return DropItem('Missing text')class MongoPipeline(object): def __init__(self, mongo_uri, mongo_db): self.mongo_uri = mongo_uri self.mongo_db = mongo_db @classmethod def from_crawler(cls, crawler): return cls( mongo_uri=crawler.settings.get('MONGO_URI'), mongo_db=crawler.settings.get('MONGO_DB') ) def open_spider(self, spider): self.client = pymongo.MongoClient(self.mongo_uri) self.db = self.client[self.mongo_db] def process_item(self, item, spider): name = item.__class__.__name__ self.db[name].insert(dict(item)) return item def close_spider(self, spider): self.client.close() from_crawler，这是一个类方法，用@classmethod标识，是一种依赖注入。它的参数就是crawler，通过crawler可以拿到全局配置的每一个配置信息。在全局配置settings.py中，可以配置MONGO_UR和MONGO_DB来指定MongoDB连接需要的地址和数据库名称，拿到配置信息之后返回类对象即可。所以这个方法主要是用来获取settings.py中的配置信息。 open_spider，当Spider开启时，这个方法被调用。进行初始化操作。 close_spider，当Spider关闭时，这个方法被调用。将数据库连接关闭。 最主要的process_item()方法则进行了数据插入操作。 定义好的TutorialPipeline和MongoPipline这两个类后，我们需要在settings.py中使用它们，MongoDB的连接信息也需要在settings.py中定义。 settings.py中加入如下内容： 123456ITEM_PIPELINES = &#123; 'tutorial.pipelines.TutorialPipeline': 300, 'tutorial.pipelines.MongoPipeline': 400,&#125;MONGO_URI = 'localhost'MONGO_DB = 'tutorial' 赋值ITEM_PIPELINES字典，键名是Pipeline的类名称，键值是调用的优先级，是一个数字，数字越小对应的Pipeline越先被调用。 重新执行如下命令进行爬取： scrapy crawl quotes 结束后，MongoDB中会创建了一个tutorial的数据库、TutorialItem的表，如下图： 11. 结语至此，一个简单的Scrapy框架爬虫就完成了，这只是一个简单的爬虫例子，Github上面也有许多相关的项目可以去研究~~~]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3 使用pip安装（命令行中）失败或 “not a supported wheel” 解决方案！]]></title>
    <url>%2F2018%2F07%2F17%2Fpython3-%E4%BD%BF%E7%94%A8pip%E5%AE%89%E8%A3%85%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%EF%BC%89%E5%A4%B1%E8%B4%A5%E6%88%96-%E2%80%9Cnot-a-supported-wheel%E2%80%9D-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%81%2F</url>
    <content type="text"><![CDATA[python3 使用pip安装（命令行中）失败或 “not a supported wheel” 解决方案！ 原因1：安装的不是对应python版本的库，下载的库名中cp36代表python3.6,其它同理。 原因2：（我遇到的情况—-下载的是对应版本的库，然后仍然提示不支持当前平台） 百度了一下，说法如下： 在shell中输入import pip; print(pip.pep425tags.get_supported())可以获取到pip支持的文件名还有版本 然而，很悲催。。。。出现了 然后，google了一下，解决了~ 因为我的pip的版本是V10，应该使用下面的命令： import pip._internal; print(pip._internal.pep425tags.get_supported()) 嘿嘿~~]]></content>
      <categories>
        <category>Python3笔记</category>
      </categories>
      <tags>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速查看linux命令常用用法---------tldr]]></title>
    <url>%2F2018%2F07%2F05%2FTLDR%2F</url>
    <content type="text"><![CDATA[前言之前我们如果用一个命令，但是忘了具体的参数是什么的时候，通常会用man，比如： man tar 这样，man就会告诉我们tar的具体用法，但是man有时候特别的冗长，你要找到想要的例子非常困难，所以tldr命令就是一个很好的补充，tldr会告诉你一些tar的常用例子和用法。 安装tldr安装tldr特别简单，具体命令如下： sudo curl -o /usr/local/bin/tldr https://raw.githubusercontent.com/raylee/tldr/master/tldr &amp;&amp; sudo chmod +x /usr/local/bin/tldr 这样，tldr就安装完成了，下面我们来使用tldr查看find命令的常用用法： 12345678910111213141516171819202122232425262728293031[dazhan@ecs47.101.138.203 ~]$ tldr findfindFind files or directories under the given directory tree, recursively.- Find files by extension: find root_path -name '*.ext'- Find files by matching multiple patterns: find root_path -name '*pattern_1*' -or -name '*pattern_2*'- Find directories matching a given name: find root_path -type d -name *lib*- Find files matching path pattern: find root_path -path '**/lib/**/*.ext'- Run a command for each file, use &#123;&#125; within the command to access the filename: find root_path -name '*.ext' -exec wc -l &#123;&#125; \;- Find files modified in the last 24-hour period: find root_path -mtime -1- Find files using case insensitive name matching, of a certain size: find root_path -size +500k -size -10M -iname '*.TaR.gZ'- Delete files by name, older than 180 days: find root_path -name '*.ext' -mtime +180 -delete- Find files matching a given pattern, while excluding specific paths: find root_path -name '*.py' -not -path '*/site-packages/*']]></content>
      <categories>
        <category>Linux笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
